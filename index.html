<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Google Earth with Cesium</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Cesium.js"></script>
    <link href="https://cesium.com/downloads/cesiumjs/releases/1.111/Build/Cesium/Widgets/widgets.css" rel="stylesheet">
    <style>
        html, body, #cesiumContainer {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #cesiumContainer {
            position: relative;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 1000;
        }
        
        
        .error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ff4444;
            font-size: 16px;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 5px;
            z-index: 1000;
        }
        
        .api-loading {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
        }
        
        .marker-count {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 14px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="cesiumContainer">
        <div class="loading" id="loading">Loading Google Earth...</div>
        <div class="api-loading" id="apiLoading" style="display: none;">Loading observation data...</div>
        <div class="marker-count" id="markerCount" style="display: none;"></div>
    </div>

    <script>
        // Set your Cesium ion access token
        Cesium.Ion.defaultAccessToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiIyNjE5YzM0YS0xY2U1LTQ4MTUtOWE0OC1jYmUxNWQzMzhlYzIiLCJpZCI6MzUzMDM5LCJpYXQiOjE3NjExNDQ4MjB9.DK3Gva2bT-QRpHsGaYoiP-8-rEDrbaJssXn86VtW4jo';

        // Google API Key
        const GOOGLE_API_KEY = 'AIzaSyD2giSSg9PnWDyLspj8Y-xt6ztx0-eGno8';

        let viewer;
        let osmBuildings;

        // Initialize Cesium viewer
        async function initializeViewer() {
            try {
                viewer = new Cesium.Viewer('cesiumContainer', {
                terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(1),
                imageryProvider: new Cesium.GoogleEarthEnterpriseImageryProvider({
                    url: 'https://earth.google.com/web/',
                    channel: 1,
                    version: 1,
                    requestType: 'ImageryMaps',
                    bbox: [-180, -90, 180, 90],
                    format: 'png'
                }),
                baseLayerPicker: true,
                geocoder: true,
                homeButton: true,
                sceneModePicker: true,
                navigationHelpButton: true,
                animation: true,
                timeline: true,
                fullscreenButton: true,
                vrButton: false,
                selectionIndicator: true,
                infoBox: true,
                scene3DOnly: false,
                shouldAnimate: true
            });

            // Hide the loading message
            document.getElementById('loading').style.display = 'none';

            // Set initial camera position to polygon area
            const polygonCoordinates = [
                [144.97414462677202,-37.80102882726442],
                [144.97000329605302,-37.800791461768725],
                [144.96968143097124,-37.80318203655827],
                [144.96794335952958,-37.80301249479613],
                [144.9683081399556,-37.80067277873483],
                [144.96320121399125,-37.80029977367253],
                [144.96251456848344,-37.807547397902205],
                [144.9637161981221,-37.810131613495315],
                [144.97058265320024,-37.80789384149249],
                [144.97339360824785,-37.80857196138209]
            ];



            // Enable 3D buildings
            enable3DBuildings();

            // Add polygon area
            addPolygonArea();

            // Add observation markers
            addObservationMarkers();

            // Configure marker visibility settings
            configureMarkerVisibility();

            // Handle errors
            viewer.cesiumWidget.cesiumInspector = false;

            } catch (error) {
                console.error('Error initializing Cesium:', error);
                document.getElementById('loading').innerHTML = '<div class="error">Error loading Google Earth. Please check your internet connection and try again.</div>';
            }
        }

        // Call the async function
        initializeViewer();

        // Function to fetch data from BioSmart API
        async function fetchObservationData() {
            try {
                console.log('Fetching data from BioSmart API...');
                const response = await fetch('https://portal.biosmart.life/api/v1/observations/contest_region?contest_id=109&region_id=12436&limit=2000', {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                        'Content-Type': 'application/json'
                    },
                    mode: 'cors'
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('API Data received:', data);
                console.log('Data structure:', JSON.stringify(data, null, 2));
                
                return data;
            } catch (error) {
                console.error('Error fetching observation data:', error);
                console.error('Error details:', error.message);
                
                // Show error message to user
                document.getElementById('apiLoading').innerHTML = 'Error loading data: ' + error.message;
                document.getElementById('apiLoading').style.color = '#ff4444';
                
                // Return sample data for testing if API fails
                console.log('Using sample data for testing...');
                return {
                    data: {
                        observations: [
                            { id: 1, lat: -37.8136, lng: 144.9631, common_name: 'Red Kangaroo', species: 'Macropus rufus', notes: 'Large male kangaroo spotted', created_at: '2024-01-01' },
                            { id: 2, lat: -37.8146, lng: 144.9641, common_name: 'Koala', species: 'Phascolarctos cinereus', notes: 'Koala in eucalyptus tree', created_at: '2024-01-02' },
                            { id: 3, lat: -37.8156, lng: 144.9651, common_name: 'Emu', species: 'Dromaius novaehollandiae', notes: 'Adult emu walking', created_at: '2024-01-03' },
                            { id: 4, lat: -37.8166, lng: 144.9661, common_name: 'Kookaburra', species: 'Dacelo novaeguineae', notes: 'Laughing kookaburra', created_at: '2024-01-04' },
                            { id: 5, lat: -37.8176, lng: 144.9671, common_name: 'Wombat', species: 'Vombatus ursinus', notes: 'Common wombat burrow', created_at: '2024-01-05' }
                        ]
                    }
                };
            }
        }

        // Function to create teardrop marker SVG
        function createTeardropMarker(color = '#ff6b6b', size = 30, letter = '') {
            const svg = `
                <svg width="${size}" height="${size}" viewBox="0 0 30 30" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <filter id="shadow" x="-50%" y="-50%" width="200%" height="200%">
                            <feDropShadow dx="2" dy="2" stdDeviation="3" flood-color="rgba(0,0,0,0.3)"/>
                        </filter>
                        <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:${color};stop-opacity:1" />
                            <stop offset="100%" style="stop-color:${color}dd;stop-opacity:1" />
                        </linearGradient>
                    </defs>
                    <path d="M15 2 C20 2, 25 7, 25 12 C25 17, 20 22, 15 22 C10 22, 5 17, 5 12 C5 7, 10 2, 15 2 Z" 
                          fill="url(#gradient)" 
                          filter="url(#shadow)"
                          stroke="#fff" 
                          stroke-width="1"/>
                    <circle cx="15" cy="12" r="3" fill="#fff" opacity="0.8"/>
                    ${letter ? `<text x="15" y="17" text-anchor="middle" font-family="Arial, sans-serif" font-size="16" font-weight="bold" fill="#000000" stroke="white" stroke-width="1">${letter}</text>` : ''}
                </svg>
            `;
            return 'data:image/svg+xml;base64,' + btoa(svg);
        }

        // Function to add markers to the map
        async function addObservationMarkers() {
            // Show API loading indicator
            document.getElementById('apiLoading').style.display = 'block';
            
            const data = await fetchObservationData();
            console.log('Raw API response:', data);
            
            // Check different possible data structures
            let observations = null;
            if (data && data.data && Array.isArray(data.data.observations)) {
                observations = data.data.observations;
                console.log('Found observations in data.data.observations');
            } else if (data && Array.isArray(data.observations)) {
                observations = data.observations;
                console.log('Found observations in data.observations');
            } else if (data && Array.isArray(data.data)) {
                observations = data.data;
                console.log('Found observations in data.data');
            } else if (Array.isArray(data)) {
                observations = data;
                console.log('Found observations in root data');
            } else {
                console.error('No valid observations array found in API response');
                console.error('Available keys:', data ? Object.keys(data) : 'No data');
                document.getElementById('apiLoading').innerHTML = 'No valid data structure found';
                document.getElementById('apiLoading').style.color = '#ff4444';
                return;
            }

            if (!observations || observations.length === 0) {
                console.error('No observations found in data');
                document.getElementById('apiLoading').innerHTML = 'No observations found';
                document.getElementById('apiLoading').style.color = '#ff4444';
                return;
            }

            // Take first 30 items
            const limitedObservations = observations.slice(0, 30);
            console.log(`Adding ${limitedObservations.length} markers to the map`);
            console.log('First observation:', limitedObservations[0]);
            
            // Hide API loading and show marker count
            document.getElementById('apiLoading').style.display = 'none';
            document.getElementById('markerCount').style.display = 'block';
            document.getElementById('markerCount').textContent = `Showing ${limitedObservations.length} observations`;

            // Color palette for different marker colors
            const colors = [
                '#ff6b6b', '#4ecdc4', '#45b7d1', '#96ceb4', '#feca57',
                '#ff9ff3', '#54a0ff', '#5f27cd', '#00d2d3', '#ff9f43',
                '#ee5a24', '#0984e3', '#6c5ce7', '#a29bfe', '#fd79a8',
                '#fdcb6e', '#e17055', '#00b894', '#e84393', '#2d3436',
                '#74b9ff', '#55a3ff', '#fd79a8', '#fdcb6e', '#e17055',
                '#00b894', '#e84393', '#2d3436', '#74b9ff', '#55a3ff'
            ];

            let markersAdded = 0;
            limitedObservations.forEach((observation, index) => {
                console.log(`Processing observation ${index + 1}:`, observation);
                
                // Check if observation has coordinates
                if (observation.lat && observation.lng) {
                    console.log(`Adding marker for observation ${index + 1} at lat: ${observation.lat}, lng: ${observation.lng}`);
                    
                    const color = colors[index % colors.length];
                    
                    // Extract first capital letter from common name or species
                    const nameToUse = observation.common_name || observation.species || `Obs ${index + 1}`;
                    const firstLetter = nameToUse.match(/[A-Z]/)?.[0] || nameToUse.charAt(0).toUpperCase();
                    
                    const markerUrl = createTeardropMarker(color, 40, firstLetter);

                    // Create billboard entity
                    const entity = viewer.entities.add({
                        position: Cesium.Cartesian3.fromDegrees(
                            parseFloat(observation.lng),
                            parseFloat(observation.lat),
                            0
                        ),
                        billboard: {
                            image: markerUrl,
                            width: 40,
                            height: 40,
                            verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                            scaleByDistance: new Cesium.NearFarScalar(1.5e2, 1.0, 1.5e7, 0.3),
                            translucencyByDistance: new Cesium.NearFarScalar(1.5e2, 1.0, 1.5e7, 0.2),
                            heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                            disableDepthTestDistance: Number.POSITIVE_INFINITY
                        }
                    });

                    // Add click handler for popup
                    entity.description = `
                        <div style="padding: 10px; font-family: Arial, sans-serif;">
                            <h3 style="margin: 0 0 10px 0; color: #333;">${observation.common_name || observation.species || `Observation #${index + 1}`}</h3>
                            <p><strong>ID:</strong> ${observation.id || 'N/A'}</p>
                            <p><strong>Latitude:</strong> ${observation.lat}</p>
                            <p><strong>Longitude:</strong> ${observation.lng}</p>
                            ${observation.common_name ? `<p><strong>Common Name:</strong> ${observation.common_name}</p>` : ''}
                            ${observation.species ? `<p><strong>Species:</strong> ${observation.species}</p>` : ''}
                            ${observation.notes ? `<p><strong>Notes:</strong> ${observation.notes}</p>` : ''}
                            ${observation.created_at ? `<p><strong>Date:</strong> ${new Date(observation.created_at).toLocaleDateString()}</p>` : ''}
                        </div>
                    `;
                    
                    markersAdded++;
                } else {
                    console.log(`Skipping observation ${index + 1} - no valid coordinates:`, observation);
                }
            });

            console.log(`Total markers added: ${markersAdded}`);
        }

        // Function to configure marker visibility settings
        function configureMarkerVisibility() {
            // Ensure entities are always visible
            viewer.scene.globe.enableLighting = false;
            viewer.scene.fog.enabled = false;
            
            // Set up camera controls for better marker visibility
            viewer.camera.minimumZoomDistance = 10;
            viewer.camera.maximumZoomDistance = 10000000;
            
            // Configure scene settings for better marker visibility
            viewer.scene.globe.enableLighting = false;
            viewer.scene.globe.showGroundAtmosphere = false;
            
            // Add event listener for camera changes to ensure markers stay visible
            viewer.camera.moveEnd.addEventListener(function() {
                // Force entities to be visible
                viewer.entities.values.forEach(entity => {
                    if (entity.billboard) {
                        entity.billboard.show = true;
                    }
                    if (entity.label) {
                        entity.label.show = true;
                    }
                });
            });
            
            console.log('Marker visibility settings configured');
        }

        // Function to enable 3D buildings
        async function enable3DBuildings() {
            try {
                // Try to load Google's 3D buildings using Google Maps API
                const googleBuildings = await Cesium.Cesium3DTileset.fromUrl(
                    `https://tile.googleapis.com/v1/3dtiles/root.json?key=${GOOGLE_API_KEY}`
                );
                viewer.scene.primitives.add(googleBuildings);
                
                // Enable shadows for better 3D effect
                viewer.shadows = true;
                viewer.scene.globe.enableLighting = true;
                
                // Set sun position for better lighting
                viewer.scene.sun.show = true;
                viewer.scene.moon.show = true;
                viewer.scene.skyBox.show = true;
                
                console.log('Google 3D Buildings loaded successfully');
            } catch (error) {
                console.error('Error loading Google 3D buildings:', error);
                // Fallback: try Cesium OSM Buildings
                try {
                    osmBuildings = await Cesium.Cesium3DTileset.fromIonAssetId(96188);
                    viewer.scene.primitives.add(osmBuildings);
                    
                    // Enable shadows for better 3D effect
                    viewer.shadows = true;
                    viewer.scene.globe.enableLighting = true;
                    
                    // Set sun position for better lighting
                    viewer.scene.sun.show = true;
                    viewer.scene.moon.show = true;
                    viewer.scene.skyBox.show = true;
                    
                    console.log('Fallback OSM Buildings loaded');
                } catch (fallbackError) {
                    console.error('All 3D building sources failed:', fallbackError);
                }
            }
        }

        // Function to add polygon area
        function addPolygonArea() {
            const polygonCoordinates = [
                [144.97414462677202,-37.80102882726442],
                [144.97000329605302,-37.800791461768725],
                [144.96968143097124,-37.80318203655827],
                [144.96794335952958,-37.80301249479613],
                [144.9683081399556,-37.80067277873483],
                [144.96320121399125,-37.80029977367253],
                [144.96251456848344,-37.807547397902205],
                [144.9637161981221,-37.810131613495315],
                [144.97058265320024,-37.80789384149249],
                [144.97339360824785,-37.80857196138209]
            ];

            // Convert coordinates to Cesium format
            const positions = polygonCoordinates.map(coord => 
                Cesium.Cartesian3.fromDegrees(coord[0], coord[1])
            );

            // Add polygon entity with no top/bottom surfaces
            viewer.entities.add({
                polygon: {
                    hierarchy: positions,
                    material: Cesium.Color.YELLOW.withAlpha(0.5),
                    outline: true,
                    outlineColor: Cesium.Color.YELLOW,
                    height: 0,
                    extrudedHeight: 100,
                    closeTop: false,
                    closeBottom: false
                }
            });

            // Calculate center point for camera positioning
            const centerLongitude = polygonCoordinates.reduce((sum, coord) => sum + coord[0], 0) / polygonCoordinates.length;
            const centerLatitude = polygonCoordinates.reduce((sum, coord) => sum + coord[1], 0) / polygonCoordinates.length;

            // Calculate offset to center the polygon with -45Â° pitch
            const offsetDistance = -0.01; // Adjust this value to fine-tune centering
            const offsetLatitude = centerLatitude + offsetDistance;

            // Set camera to focus on the polygon area from behind
            viewer.camera.setView({
                destination: Cesium.Cartesian3.fromDegrees(centerLongitude, offsetLatitude, 1000),
                orientation: {
                    heading: Cesium.Math.toRadians(0.0),
                    pitch: Cesium.Math.toRadians(-45.0),
                    roll: 0.0
                }
            });
        }


        // Handle window resize
        window.addEventListener('resize', function() {
            if (viewer) {
                viewer.resize();
            }
        });
    </script>
</body>
</html>
